---
title: Guix Services Tutorial
draft: true
date: 2024-12-01
tags: [guix]
---

## Quick concepts

-   a *service* can be a one-shot task, or a long-running daemon;
-   a *service* adds functionality to the operating system and/or
    configure its built-in functionalities;
-   a *service* can collaborate with other *services*. This
    collaboration is called *extension*, and it is a way for composing
    *services*. A client *service C* extends a server *service S*, when
    TODO
-   a *service-type* defined in Guix is a template that can have many
    instances in a running-system, e.g.Â there can be two instances of
    *secure-shell-service* listening on different ports and with
    different access methods;
-   a *service* can be defined for being extensible by other *services*.
    TODO compose; TODO extend; TODO all extensible services admit only
    one instance?

MAYBE a service extension is a way for service C to use service S, but
not at run-time, but during configuration, adding new rules and settings
to the service S. The evaluation is done at compile-time and not at
run-time, during service initialization.

TODO see of actions are managed by services

TODO check differences between shepherd-services and service-type. For
example elogind-shepherd-service.

FACT they are generated by `guix system shepherd-graph` 

FACT the root of shepherd-services is `root-file-system` 

FACT they have the `requirment` list of services from which they
depend, and it is a list of symbols 

FACT `actions` is a list
of `shepherd-action` to call from `herd` 

FACT
`shepherd-root-service-type` is the service-type that
extensions target when they want to create shepherd servces 

FACT
`%shepherd-root-service` is the root shepherd service with
PID 1 

FACT service configurations are expressed with scheme
*record-types* and converted to service specific format by Guix



FACT a `service-type` has no `requirement` slot


FACT a `service-type` is a logical type of service, that then
interact with `shepherd-services` or other
`service-type` for configuring them and providing the
desidered feature. A single `service-type` (i.e. a feature)
can configure more than one (physical) `shepherd-service`


FACT `service-type` are generated by
`guix system extension-graph`



FACT the list of objects returned by the *extension section* of an
object is composed by argument `compose` of the server
`service-type`

FACT the final object sent to the server `service-type` is
managed by `extend` function and it update the called
*service*

FACT a `service-type` without `extend` cannot be
extended because it does not know how to manage extension requests

FACT the workflow is this:

-   `service-type` `C` receive a configuration;
-   for each `service-type` `S`, `C`
    prepares a list of extension requests `R`;
-   for each `S`, all the requests are composed/folded
    toghether using `compose` of `S`, and
    producing a folded request `F`;
-   `F` is sent to `S`, and the procedure
    `extend` of `S` is responsable for updating
    `S` with `F`;

FACT the list of objects returned by `extensions` and
associated to a specific `service`, are `composed`
using the function `compose` TODO doublecheck, there is
another function 

FACT every `service-type` has at least one
*service extension*, otherwise it has no effects

MAYBE the fact that the documentation lack a workflow graph is rather
disturbing/strange.

FACT the problem is that many services are not dynamic Scheme active
objects, but they are Linux services, that are not dynamic, i.e. they
are configured at startup but their configuration never change. So, the
Guix configuration approach is a way for computing during configuration
execution all the configurations of the services, in a rather
declarative way. The *declarative way* is obtained specifying in the
framework how to compose the rules added by various service.

## Services usage

Services usage it is rather simple.

