Title: How to run Docker services in Guix
Date: 2024-11-
Category: Guix
tags: guix

Sometime it is easier/quicker to reuse a Docker service, rather than porting it to #Guix. Thanks to #Shepherd, the service is still a declarative specification. 

## Gotchas

I'm not sure of this (I should double-check), but apparently during `guix deploy`, I had to install and boot services in a strict order:

```scheme

    (services
      (cons*
        (service openssh-service-type)
        (service dhcp-client-service-type)

        (service dbus-root-service-type)

        ;; after reboot activate also this 
        ;; (service elogind-service-type)

        ;; after reboot activate also this 
        ;; (service containerd-service-type)

        ;; after reboot activate also this
        ;; (service docker-service-type)
```

then add "docker" group to interested users, with something like

```scheme
    (users (cons*
            (user-account
               (name "mzan")
               (comment "Massimo")
               (group "users")
               (home-directory "/home/mzan")
               (supplementary-groups '("wheel" "netdev" "docker" "audio" "video" )))
            (user-account
              (name "deploy")
              (comment "Guix deploy user")
              (group "users")
              (home-directory "/home/deploy")
              (supplementary-groups '("wheel" "netdev" "docker")))
            %base-user-accounts))
```

TODO check and in case signal a bug-report

Title: Guix Services Tutorial
Date: 2024-11-
Category: Guix
tags: guix

This is a tutorial about [Guix Shepherd Services
Composition](https://guix.gnu.org/manual/en/html_node/Service-Composition.html).
The source code is published on
<https://github.com/massimo-zaniboni/guix-services-tutorial>

## The original problem

I want to mount a bcachefs file-sistem at boot. I want to use a one-shot
job, because bcachefs is not yet fully supported by GuixSD. I want to
mount this file-system before other jobs, because some directories like
`/var/lib`{.verbatim} are rather important.

By the way: I left the root file-system with `/gnu/store`{.verbatim} on
a BTRFS partition because GuixSD reads the kernel from the
`/gnu/store`{.verbatim}, and GRUB does not supports yet bcachefs.

This is my initial setting

``` scheme
(simple-service
  'mount-bcachefs
  shepherd-root-service-type
  (list (shepherd-service
          (documentation "Mount a bcachefs in /mnt/bcachefs")
          (provision '(mount-bcachefs))
          (one-shot? #t)
          (respawn? #f)
          (auto-start? #t)
          (start #~(lambda _
                        (system* (string-append #+bcachefs-tools "/sbin/mount.bcachefs")
                                 "/dev/sdb:/dev/sdc:/dev/sdd"
                                 "/mnt/bcachefs/"))))))
```

TODO the graph with service dependencies does not contain some services
visible by `sudo herd status`{.verbatim}. They are only in dependencies,
but not in extensions.

TODO there are two axis: service depend from; service extend.

## Quick concepts

-   a *service* can be a one-shot task, or a long-running daemon;
-   a *service* adds functionality to the operating system and/or
    configure its built-in functionalities;
-   a *service* can collaborate with other *services*. This
    collaboration is called *extension*, and it is a way for composing
    *services*. A client *service C* extends a server *service S*, when
    TODO
-   a *service-type* defined in Guix is a template that can have many
    instances in a running-system, e.g.Â there can be two instances of
    *secure-shell-service* listening on different ports and with
    different access methods;
-   a *service* can be defined for being extensible by other *services*.
    TODO compose; TODO extend; TODO all extensible services admit only
    one instance?

MAYBE a service extension is a way for service C to use service S, but
not at run-time, but during configuration, adding new rules and settings
to the service S. The evaluation is done at compile-time and not at
run-time, during service initialization.

TODO see of actions are managed by services

TODO check differences between shepherd-services and service-type. For
example elogind-shepherd-service.

FACT they are generated by `guix system shepherd-graph`{.verbatim} FACT
the root of shepherd-services is `root-file-system`{.verbatim} FACT they
have the `requirment`{.verbatim} list of services from which they
depend, and it is a list of symbols FACT `actions`{.verbatim} is a list
of `shepherd-action`{.verbatim} to call from `herd`{.verbatim} FACT
`shepherd-root-service-type`{.verbatim} is the service-type that
extensions target when they want to create shepherd servces FACT
`%shepherd-root-service`{.verbatim} is the root shepherd service with
PID 1 FACT service configurations are expressed with scheme
*record-types* and converted to service specific format by Guix

FACT a `service-type`{.verbatim} has no `requirement`{.verbatim} slot
FACT a `service-type`{.verbatim} is a logical type of service, that then
interact with `shepherd-services`{.verbatim} or other
`service-type`{.verbatim} for configuring them and providing the
desidered feature. A single `service-type`{.verbatim} (i.e. a feature)
can configure more than one (physical) `shepherd-service`{.verbatim}
FACT `service-type`{.verbatim} are generated by
`guix system extension-graph`{.verbatim}

FACT the list of objects returned by the *extension section* of an
object is composed by argument `compose`{.verbatim} of the server
`service-type`{.verbatim}

FACT the final object sent to the server `service-type`{.verbatim} is
managed by `extend`{.verbatim} function and it update the called
*service*

FACT a `service-type`{.verbatim} without `extend`{.verbatim} cannot be
extended because it does not know how to manage extension requests

FACT the workflow is this:

-   `service-type`{.verbatim} `C`{.verbatim} receive a configuration;
-   for each `service-type`{.verbatim} `S`{.verbatim}, `C`{.verbatim}
    prepares a list of extension requests `R`{.verbatim};
-   for each `S`{.verbatim}, all the requests are composed/folded
    toghether using `compose`{.verbatim} of `S`{.verbatim}, and
    producing a folded request `F`{.verbatim};
-   `F`{.verbatim} is sent to `S`{.verbatim}, and the procedure
    `extend`{.verbatim} of `S`{.verbatim} is responsable for updating
    `S`{.verbatim} with `F`{.verbatim};

FACT the list of objects returned by `extensions`{.verbatim} and
associated to a specific `service`{.verbatim}, are `composed`{.verbatim}
using the function `compose`{.verbatim} TODO doublecheck, there is
another function FACT every `service-type`{.verbatim} has at least one
*service extension*, otherwise it has no effects

MAYBE the fact that the documentation lack a workflow graph is rather
disturbing/strange.

FACT the problem is that many services are not dynamic Scheme active
objects, but they are Linux services, that are not dynamic, i.e. they
are configured at startup but their configuration never change. So, the
Guix configuration approach is a way for computing during configuration
execution all the configurations of the services, in a rather
declarative way. The *declarative way* is obtained specifying in the
framework how to compose the rules added by various service.

## Services usage

Services usage it is rather simple.

## Tasks

### [TODO]{.todo .TODO} add author and license {#add-author-and-license}

## TODO

Title: Guix gotchas
Date: 2024-11-
Category: Guix
tags: guix

These are #LearnedLessons, during my usage of #Guix, but based on maybe not replicable problems. So they can be involuntary [FUD](https://en.wikipedia.org/wiki/Fear,_uncertainty,_and_doubt). In any case they are not big problems, mainly gotchas.

## Not use local packages

It is better using 

```
guix shell some-package
```

than

```
guix install some-package
```

because sometime the removal of `some-package` (i.e. `guix package -r some-package`), can create problems on the profile, also for other applications. After a reboot it is all ok.

My usual workflow is:
- if possible, I use `direnv` and `guix.scm` for creating isolated, per-project environment;
- when useful, I install packages globally, in the configuration file; 
- for quick usage and testing use only `guix shell some-package`;
- I never use `guix install some-package`;

## Package definitions

### "inherit"

It seems that `inherit` works correctly only inside the same module of the redefined package. For example, the package `pipewire-for-hyprland` must be defined in the `gnu packages linux` module, where `pipewire` is defined:

```lisp
(define-module (gnu packages linux)
  ...)

(define-public pipewire
  (package
    (name "pipewire")
    (version "1.2.5")
    ...))

(define-public pipewire-for-hyprland
   (package
    (inherit pipewire)
    (name "pipewire-for-hyprland")
    ...))
```
TODO doublecheck this 

# Services

## guix-daemon

If I change configurations and I execute 
```
sudo guix system reconfigure
```
I need to restart the service with an explicit 
```
sudo herd stop git-daemon
sudo herd start git-daemon
```

## How services work

TODO
